'use strict';

var assign = require('react/lib/Object.assign');

var Validator = function Validator() {
  this.validationSchema = [];
  this._validator = require('validator');
  this.messages = assign({}, Validator.messages);
};

Validator.messages = {
  alpha: 'Must be letters only (A-Z)',
  number: 'Must be a number',
  url: 'Must be a URL',
  date: 'Must be a date',
  before: 'Must be before ${before}',
  after: 'Must be after ${after}',
  oneOf: 'Must be one of ${allowed}',
  email: 'Must be an email',
  creditCard: 'Please enter a valid credit card',
  max: 'Must be less than ${max}',
  min: 'Must be greater than ${min}',
  maxLength: 'Must be less than ${max} characters',
  minLength: 'Must be at least ${min} characters',
  pattern: 'Does not match pattern',
  currency: 'Must be a valid currency',
  hexColor: 'Must be a valid hex color'
};

Validator.definitions = {
  email: function email() {
    return {
      validate: this._validator.isEmail
    };
  },
  url: function url(options) {
    return {
      validate: function validate(value) {
        return this._validator.isURL(value, options);
      }
    };
  },
  date: function date() {
    return {
      validate: this._validator.isDate
    };
  },
  before: function before(_before) {
    return {
      validate: function validate(value) {
        return this._validator.isBefore(value, _before);
      },
      message: function message(m) {
        return m.replace('${before}', _before);
      }
    };
  },
  after: function after(_after) {
    return {
      validate: function validate(value) {
        return this._validator.isAfter(value, _after);
      },
      message: function message(m) {
        return m.replace('${after}', _after);
      }
    };
  },
  number: function number() {
    return {
      validate: this._validator.isNumeric
    };
  },
  alpha: function alpha() {
    return {
      validate: this._validator.isAlpha
    };
  },
  max: function max(_max) {
    return {
      validate: function validate(val) {
        return this._validator.isInt(val, { max: _max }) || this._validator.isFloat(val, { max: _max });
      },
      message: function message(m) {
        return m.replace('${max}', _max);
      }
    };
  },
  min: function min(_min) {
    return {
      validate: function validate(val) {
        return this._validator.isInt(val, { min: _min }) || this._validator.isFloat(val, { min: _min });
      },
      message: function message(m) {
        return m.replace('${min}', _min);
      }
    };
  },
  maxLength: function maxLength(max) {
    return {
      validate: function validate(val) {
        return this._validator.isLength(val, 0, max);
      },
      message: function message(m) {
        return m.replace('${max}', max);
      }
    };
  },
  minLength: function minLength(min) {
    return {
      validate: function validate(val) {
        return this._validator.isLength(val, min);
      },
      message: function message(m) {
        return m.replace('${min}', min);
      }
    };
  },
  creditCard: function creditCard() {
    return {
      validate: this._validator.isCreditCard
    };
  },
  oneOf: function oneOf(allowed) {
    var _this = this;

    return {
      validate: function validate(val) {
        return _this._validator.isIn(val, allowed);
      },
      message: function message(m) {
        return m.replace('${allowed}', allowed.join(', '));
      }
    };
  },
  pattern: function pattern(_pattern) {
    var _this2 = this;

    return {
      validate: function validate(val) {
        return _this2._validator.matches(val, _pattern);
      }
    };
  },
  currency: function currency(options) {
    return {
      validate: function validate(value) {
        return this._validator.isCurrency(value, options);
      }
    };
  },
  hexColor: function hexColor() {
    return {
      validate: this._validator.isHexColor
    };
  },
  custom: function custom(definition) {
    return definition;
  }
};

Object.keys(Validator.definitions).forEach(function (key) {
  Validator[key] = Validator.prototype[key] = function () {
    var instance = this instanceof Validator ? this : new Validator();
    var schema = Validator.definitions[key].apply(instance, arguments);

    var lastArg = arguments[arguments.length - 1];
    var customMessage = lastArg && typeof lastArg === 'object' && lastArg.message;

    // If the validation function specifies a function, run the message template
    // through it
    if (typeof schema.message === 'function') {
      var template = schema.message;
      schema.message = function () {
        return template.call(instance, customMessage || instance.messages[key] || '');
      };
    } else {
      schema.message = function () {
        return customMessage || instance.messages[key] || '';
      };
    }

    instance.validationSchema.push(schema);

    return instance;
  };
});

Validator.prototype.assert = function (value, context) {
  var _this3 = this;

  var results = this.validationSchema.map(function (definition) {
    var errorMessage = definition.message.call(_this3, value);
    return definition.validate.call(context || _this3, value) ? false : errorMessage;
  }).filter(function (error) {
    return error;
  });
  return results.length ? results : false;
};

module.exports = Validator;